# utils/data_manager.py
import pandas as pd
import streamlit as st
from io import BytesIO

def load_data_from_file(uploaded_file):
    """Charge les données depuis un fichier uploadé"""
    try:
        if uploaded_file.name.endswith('.csv'):
            df = pd.read_csv(uploaded_file, encoding='utf-8')
        elif uploaded_file.name.endswith(('.xlsx', '.xls')):
            df = pd.read_excel(uploaded_file)
        else:
            return None, "Format de fichier non supporté"
        return df, None
    except Exception as e:
        return None, f"Erreur lors du chargement: {str(e)}"

def validate_dataframe(df):
    """Valide les données du DataFrame"""
    if df is None or df.empty:
        return False, "Le fichier est vide"
    
    required_columns = ['nom', 'prix']
    missing_columns = [col for col in required_columns if col not in df.columns]
    
    if missing_columns:
        return False, f"Colonnes manquantes : {', '.join(missing_columns)}"
    
    return True, "Données valides"

def clean_dataframe(df):
    """Nettoie le DataFrame"""
    df = df.dropna(how='all')
    text_columns = df.select_dtypes(include=['object']).columns
    df[text_columns] = df[text_columns].fillna('')
    return df

def get_available_columns(df):
    """Retourne la liste des colonnes disponibles"""
    return list(df.columns) if df is not None else []

def filter_dataframe(df, filters=None):
    """Applique des filtres au DataFrame"""
    if filters is None or df is None:
        return df
    
    filtered_df = df.copy()
    for column, value in filters.items():
        if value and column in filtered_df.columns:
            if isinstance(value, str):
                filtered_df = filtered_df[filtered_df[column].str.contains(value, case=False, na=False)]
            else:
                filtered_df = filtered_df[filtered_df[column] == value]
    
    return filtered_df

def export_to_excel(df):
    """Exporte le DataFrame vers Excel"""
    output = BytesIO()
    with pd.ExcelWriter(output, engine='openpyxl') as writer:
        df.to_excel(writer, sheet_name='Catalogue', index=False)
    return output.getvalue()

# utils/data_processing.py
import pandas as pd
import streamlit as st
import sqlite3
import os
from datetime import datetime

def detect_csv_type(df):
    """Détecte si le CSV provient d'Etsy ou Shopify basé sur les colonnes"""
    if df is None or df.empty:
        return "unknown"
    
    columns = [col.lower() for col in df.columns]
    
    # Détection Etsy
    etsy_indicators = ['listing_id', 'title', 'price', 'currency', 'quantity', 'state']
    if any(indicator in columns for indicator in etsy_indicators):
        return "etsy"
    
    # Détection Shopify
    shopify_indicators = ['handle', 'title', 'vendor', 'product_type', 'tags', 'published']
    if any(indicator in columns for indicator in shopify_indicators):
        return "shopify"
    
    return "unknown"

def save_feedback_to_csv(feedback_data, filename="feedback_snapcatalog.csv"):
    """Sauvegarde le feedback dans un fichier CSV"""
    try:
        df = pd.DataFrame([feedback_data])
        
        # Ajouter l'horodatage
        df['timestamp'] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        # Créer le fichier s'il n'existe pas, sinon ajouter
        if os.path.exists(filename):
            df.to_csv(filename, mode='a', header=False, index=False)
        else:
            df.to_csv(filename, index=False)
            
        return True, "Feedback sauvegardé avec succès"
    except Exception as e:
        return False, f"Erreur lors de la sauvegarde : {str(e)}"

def save_feedback_to_sqlite(feedback_data, db_path="utils/snapcatalog_feedback.db"):
    """Sauvegarde le feedback dans une base SQLite"""
    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        
        # Créer la table si elle n'existe pas
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS feedback (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                rating INTEGER,
                comment TEXT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # Insérer le feedback
        cursor.execute('''
            INSERT INTO feedback (rating, comment)
            VALUES (?, ?)
        ''', (feedback_data.get('rating'), feedback_data.get('comment')))
        
        conn.commit()
        conn.close()
        
        return True, "Feedback sauvegardé en base de données"
    except Exception as e:
        return False, f"Erreur lors de la sauvegarde en base : {str(e)}"

def get_feedback_stats(db_path="utils/snapcatalog_feedback.db"):
    """Récupère les statistiques des feedbacks"""
    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        
        # Vérifier si la table existe
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='feedback'")
        if not cursor.fetchone():
            conn.close()
            return {"total": 0, "average_rating": 0, "ratings": {}}
        
        # Statistiques générales
        cursor.execute("SELECT COUNT(*) FROM feedback")
        total = cursor.fetchone()[0]
        
        cursor.execute("SELECT AVG(rating) FROM feedback")
        avg_rating = cursor.fetchone()[0] or 0
        
        # Distribution des notes
        cursor.execute("SELECT rating, COUNT(*) FROM feedback GROUP BY rating ORDER BY rating")
        ratings_dist = dict(cursor.fetchall())
        
        conn.close()
        
        return {
            "total": total,
            "average_rating": round(avg_rating, 1),
            "ratings": ratings_dist
        }
    except Exception as e:
        return {"error": str(e)}

# utils/font_manager.py
import os
from reportlab.pdfbase.ttfonts import TTFont
from reportlab.pdfbase import pdfmetrics
import streamlit as st

def download_and_register_fonts():
    """Enregistre les polices système et retourne le mapping des polices disponibles"""
    
    try:
        # Essayer d'enregistrer les polices système
        system_fonts = {
            "Helvetica": ["/System/Library/Fonts/Helvetica.ttc", "/System/Library/Fonts/Arial.ttf", "/System/Library/Fonts/Helvetica.dfont"],
            "Courier": ["/System/Library/Fonts/Courier.ttc", "/System/Library/Fonts/Courier New.ttf", "/System/Library/Fonts/Courier.dfont"],
            "Times": ["/System/Library/Fonts/Times.ttc", "/System/Library/Fonts/Times New Roman.ttf", "/System/Library/Fonts/Times.dfont"]
        }
        
        registered_fonts = {}
        
        for font_name, font_paths in system_fonts.items():
            for font_path in font_paths:
                if os.path.exists(font_path):
                    try:
                        # Enregistrer la police
                        pdfmetrics.registerFont(TTFont(font_name, font_path))
                        registered_fonts[font_name] = font_name
                        print(f"✅ Police {font_name} enregistrée depuis {font_path}")
                        break
                    except Exception as e:
                        print(f"⚠️ Impossible d'enregistrer {font_name} depuis {font_path}: {e}")
                        continue
                else:
                    print(f"⚠️ Fichier de police non trouvé: {font_path}")
        
        # Si aucune police système n'est enregistrée, utiliser les polices intégrées
        if not registered_fonts:
            print("ℹ️ Utilisation des polices intégrées ReportLab")
            return {
                "Helvetica": "Helvetica",
                "Courier": "Courier", 
                "Times": "Times-Roman"
            }
        
        return registered_fonts
        
    except Exception as e:
        print(f"⚠️ Erreur lors de l'enregistrement des polices: {e}")
        print("ℹ️ Utilisation des polices intégrées ReportLab")
        return {
            "Helvetica": "Helvetica",
            "Courier": "Courier", 
            "Times": "Times-Roman"
        }

def get_font_name(police_choice, bold=False):
    """Convertit le choix de police en nom de police ReportLab"""
    # Mapping des polices avec leurs noms ReportLab (polices intégrées)
    font_mapping = {
        "Helvetica": "Helvetica",
        "Courier": "Courier", 
        "Times": "Times-Roman"
    }
    
    font_name = font_mapping.get(police_choice, "Helvetica")

    if bold:
        # Gestion des variantes en gras pour chaque police
        bold_mapping = {
            "Helvetica": "Helvetica-Bold",
            "Courier": "Courier-Bold", 
            "Times": "Times-Bold"
        }
        return bold_mapping.get(police_choice, "Helvetica-Bold")
    else:
        return font_name

def validate_background_color(color_hex):
    """Valide et ajuste la couleur de fond pour maintenir la lisibilité (max 10% d'opacité)"""
    # Convertir hex en RGB
    color_hex = color_hex.lstrip('#')
    r = int(color_hex[0:2], 16)
    g = int(color_hex[2:4], 16)
    b = int(color_hex[4:6], 16)
    
    # Calculer la luminosité relative (formule standard)
    luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255
    
    # Si la couleur est trop sombre (luminance < 0.9), ajuster vers une couleur plus claire
    if luminance < 0.9:
        # Ajuster vers une couleur plus claire (max 10% d'opacité)
        adjusted_r = min(255, int(r + (255 - r) * 0.9))
        adjusted_g = min(255, int(g + (255 - g) * 0.9))
        adjusted_b = min(255, int(b + (255 - b) * 0.9))
        
        # Convertir back en hex
        adjusted_hex = f"#{adjusted_r:02x}{adjusted_g:02x}{adjusted_b:02x}"
        return adjusted_hex, True
    else:
        # Toujours retourner avec le #
        return f"#{color_hex}", False
# utils/helpers.py
import pandas as pd
import streamlit as st

def update_progress(current, total, stage_percent=None, status_text=""):
    """Met à jour une barre de progression Streamlit avec granularité détaillée"""
    if total > 0:
        # Calculer la progression en tenant compte du stage_percent
        if stage_percent is not None:
            # Si stage_percent est fourni, l'utiliser directement
            progress = float(stage_percent)
        else:
            # Sinon, calculer à partir de current/total
            progress = current / total
        
        # S'assurer que la progression reste entre 0.0 et 1.0
        progress = max(0.0, min(1.0, progress))
        
        # Mettre à jour la barre de progression
        if hasattr(st, 'session_state') and hasattr(st.session_state, 'progress_bar'):
            st.session_state.progress_bar.progress(progress)
        
        # Mettre à jour le texte de statut avec pourcentage détaillé
        if hasattr(st, 'session_state') and hasattr(st.session_state, 'status_text'):
            percentage = int(progress * 100)
            if status_text:
                st.session_state.status_text.text(f"{status_text} - {percentage}% ({current}/{total})")
            else:
                st.session_state.status_text.text(f"Progression: {percentage}% ({current}/{total})")
    
    return current

def update_progress_detailed(current, total, stage_percent=None, status_text=""):
    """Version améliorée qui coordonne avec les étapes manuelles de progression"""
    if total > 0:
        # La progression des produits doit être mappée sur la plage 25% à 95%
        # (car 0-25% est géré manuellement avant, et 95-100% après)
        base_progress = 0.25  # 25% de base (étapes manuelles)
        product_progress_range = 0.70  # 70% pour les produits (25% à 95%)
        
        if stage_percent is not None:
            # Si stage_percent est fourni, l'utiliser
            progress = float(stage_percent)
        else:
            # Calculer la progression relative des produits
            product_progress = current / total
            # Mapper sur la plage 25% à 95%
            progress = base_progress + (product_progress * product_progress_range)
        
        # S'assurer que la progression reste entre 0.0 et 1.0
        progress = max(0.0, min(1.0, progress))
        
        # Mettre à jour la barre de progression
        if hasattr(st, 'session_state') and hasattr(st.session_state, 'progress_bar'):
            st.session_state.progress_bar.progress(progress)
        
        # Mettre à jour le texte de statut avec pourcentage détaillé
        if hasattr(st, 'session_state') and hasattr(st.session_state, 'status_text'):
            percentage = int(progress * 100)
            if status_text:
                st.session_state.status_text.text(f"{status_text} - {percentage}% ({current}/{total})")
            else:
                st.session_state.status_text.text(f"Génération des produits: {percentage}% ({current}/{total})")
    
    return current

def format_price(price):
    """Formate un prix"""
    try:
        return f"{float(price):.2f} €"
    except:
        return "N/A"

def clean_text(text):
    """Nettoie un texte pour l'affichage"""
    if pd.isna(text):
        return ""
    return str(text).strip()

# utils/image_processing.py
from PIL import Image as PILImage
import streamlit as st
from pathlib import Path
import pandas as pd
import tempfile  # ← AJOUTEZ
import os        # ← AJOUTEZ

def open_image(image_path):
    """Ouvre une image avec PIL"""
    try:
        return PILImage.open(image_path)
    except Exception as e:
        st.error(f"Erreur ouverture image {image_path}: {e}")
        return None

def get_image_info(image_path):
    """Récupère infos d'une image"""
    img = open_image(image_path)
    if img:
        return {
            'size': img.size,
            'mode': img.mode,
            'format': img.format
        }
    return None

def get_hex_color_safe(col):
    """Retourne une couleur hexadécimale sécurisée."""
    if col is None:
        return "#FFFFFF"
    col = str(col).strip()
    if col.startswith('#'):
        return col
    else:
        return f"#{col}"

        # Ajoutez cette fonction à la fin de votre image_processing.py
def get_image(path_or_url, max_width_cm, max_height_cm, centered=False):
    if pd.isna(path_or_url) or not str(path_or_url).strip():
        return None
    path_or_url = str(path_or_url)
    if path_or_url.lower().startswith("http"):
        import urllib.request
        temp_img = tempfile.NamedTemporaryFile(delete=False, suffix=".jpg")
        try:
            urllib.request.urlretrieve(path_or_url, temp_img.name)
            path = temp_img.name
        except Exception:
            return None
    elif os.path.isfile(path_or_url):
        path = path_or_url
    else:
        return None
    # ... reste du code
def process_images(df):
    """Traite les images depuis les URLs ou fichiers locaux"""
    images = []
    for idx, row in df.iterrows():
        # Utilise votre fonction get_image existante
        img_path = row.get('image_path', '') or row.get('Image', '')
        img = get_image(img_path, 5, 5)  # 5cm max
        images.append(img)
    return images
# utils/text_processing.py
from reportlab.pdfbase import pdfmetrics
import re

# Constantes pour les espaces
NBSP = '\u00A0'  # Espace insécable
NARROW_NBSP = '\u202F'  # Espace insécable fine

def wrap_lines_by_width(text, font_name, font_size, max_width_pts, max_lines=2):
    """
    Coupe le texte par mots en veillant à ne jamais dépasser max_width_pts.
    Retourne (lines, real_max_width) avec au plus max_lines lignes.
    Plus robuste que la version précédente (ne perd pas de mots dupliqués).
    """
    words = text.split()
    lines = []
    cur = []
    real_max = 0.0

    def width_of(ws):
        s = " ".join(ws)
        return pdfmetrics.stringWidth(s, font_name, font_size)

    for w in words:
        test = cur + [w]
        if width_of(test) <= max_width_pts or not cur:
            cur = test
        else:
            # on fige la ligne courante
            w_cur = width_of(cur)
            real_max = max(real_max, w_cur)
            lines.append(" ".join(cur))
            cur = [w]
            if len(lines) >= max_lines - 1:
                # dernière ligne: on met tout le reste
                rest = " ".join([w] + words[words.index(w)+1:])
                if rest:
                    lines.append(rest)
                break

    if len(lines) < max_lines and cur:
        w_cur = width_of(cur)
        real_max = max(real_max, w_cur)
        lines.append(" ".join(cur))

    # recalcule la largeur réelle max
    for ln in lines:
        real_max = max(real_max, pdfmetrics.stringWidth(ln, font_name, font_size))

    # tronque si plus de lignes que max_lines (sécurité)
    return lines[:max_lines], real_max

def truncate(txt, n=50):
    txt = str(txt)
    return (txt[:n] + '...') if len(txt) > n else txt

def _strip_spaces(s: str) -> str:
    if s is None:
        return ""
    # Normalise les espaces: remplace fine/insécables par espace simple, compresse
    s = s.replace(NBSP, " ").replace(NARROW_NBSP, " ")
    s = re.sub(r"\s+", " ", s.strip())
    return s
